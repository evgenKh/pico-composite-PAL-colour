a #define for anamorphic stretch
one all joined together array so one idx pointer with 3 offsets?
val = val = calc assignment
rather than array = array assignment
put desired pixel in temp variable and assign that?
one big interleaved array
maybe that garbage line at the top is something not being initialised, check switch statement

get out scope and compare timings again...

is there a better way of doing the duplication?
let's jigger the start of the frame some? I think we'll have to underscan

slightly faster to read from RAM x3 than to do the bit shifts for yuv? (10%)
so store in yuv? 
84x125 anamorphic
effective & actual xresolution?
yes shows more, but not as much as I hoped
    58 out of 84 pixels
    could go 3 to 1 anamorphic (56x84?), but such low detail :(



it seems like array access is what's killing speed

30 samples/pixel?



while loop?


test with regular pico and same DAC
test with pico in regular vga board DAC



=====

some recorded timings...

for 39 loops:
explicit: 54 us
looped: 41 for
currentline instead of array lookup: 11.5
pointer method: 41 us
bitshift instead of division: 35
bitshift with and instead of division: 35
bitshifts and square sine and taking out whitelevel: 37
squaresine same speed as proper sine
memset blanks then +=: 45
taking the assumed division by 128 for levelwhite out and adding levelblank to take level white out of the brackets
^^^ that: 32.5 us
sequential interleaved sin/cos: 33 us
y=u=v=currentline: 4.2us
^^that and sin&cos = currentline: 1.9 us


24 us doing the porches
3.2 us of that is the dma copy

